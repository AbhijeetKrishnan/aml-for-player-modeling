#!/usr/bin/env python

# Usage: python repair-types.py input-domain.pddl template-domain.pddl [output-domain.pddl]
# input-domain.pddl is expected to be an action model file generated by FAMA, lacking type information and with inconsistent naming of action parameters.
# template-domain.pddl is expected to be a PDDL for the same domain, but with the type information intact.
#   The domain originally used to generate the trajectory that was fed into FAMA will work fine for this.
# output-domain.pddl is the name of the location where the repaired input-domain.pddl should be saved.
#   If a third command-line argument is not supplied, this will default to standard output.

import PDDL
import sys

def translate(data, translation):
    out = []
    for pred in data:
        newPred = []
        for item in pred:
            if item in translation:
                newPred.append(translation[item])
            else:
                newPred.append(item)
        out.append(newPred)
    return out

domain = PDDL.PDDL_Parser()
domain.parse_domain(sys.argv[1])

template = PDDL.PDDL_Parser()
template.parse_domain(sys.argv[2])

domain.types = template.types

# print(domain.types)

for act in domain.actions:
    # print(act)
    translation = {}
    for i, param in enumerate(act.parameters):
        # print(i)
        # print(param)
        translation['?o{}'.format(i + 1)] = param[0]
    act.positive_preconditions = translate(act.positive_preconditions, translation)
    act.negative_preconditions = translate(act.negative_preconditions, translation)
    act.add_effects = translate(act.add_effects, translation)
    act.del_effects = translate(act.del_effects, translation)
    # print(act)

if len(sys.argv) > 3:
    fout = open(sys.argv[3], 'w')
else:
    fout = sys.stdout

fout.write('(define (domain {})\n'.format(domain.domain_name))
fout.write('(:requirements {})\n'.format(' '.join(domain.requirements)))
fout.write('(:types {})\n'.format(' '.join(domain.types)))

stringed_preds = []
for name, argdict in domain.predicates.items():
    arglist = []
    for argname, argtype in argdict.items():
        arglist.append('{} - {}'.format(argname, argtype))
    stringed_preds.append('({} {})'.format(name, ' '.join(arglist)))

fout.write('(:predicates {})\n'.format('\n'.join(stringed_preds)))

for act in domain.actions:
    fout.write('(:action {}\n'.format(act.name))
    par_strings = []
    for par in act.parameters:
        par_strings.append(' - '.join(par))
    fout.write(':parameters ({})\n'.format(' '.join(par_strings)))
    precon_strings = []
    for precon in act.positive_preconditions:
        precon_strings.append('({})'.format(' '.join(precon)))
    for precon in act.negative_preconditions:
        precon_strings.append('(not ({}))'.format(' '.join(precon)))
    fout.write(':precondition (and {})\n'.format('\n'.join(precon_strings)))
    effect_strings = []
    for effect in act.add_effects:
        effect_strings.append('({})'.format(' '.join(effect)))
    for effect in act.del_effects:
        effect_strings.append('(not ({}))'.format(' '.join(effect)))
    fout.write(':effect (and {})\n'.format('\n'.join(effect_strings)))
    fout.write(')\n')

fout.write(')')






