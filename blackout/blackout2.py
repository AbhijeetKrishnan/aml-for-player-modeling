#!/usr/bin/env python

from PDDL import PDDL_Parser
import pprint
import blackout1
import sys
import time

# OK, so the goal here is to compute the minimum set of preconditions to account for all the actions which the player was not allowed to take.
# Time to classify preconditions.
# Predicate (present | absent) in (none | some | all) states before (successful | failed) actions

# A predicate always present is one that's never absent, and vice versa.
# And by "some" I mean "some but not all", so it's its own negation.
# So that simplifies things. I can just talk about the presence of a predicate, without separately considering its absence.

# If Predicate P is present in the states preceding S successful actions and U unsuccessful actions, we call it this:
#   U\S all         some                none    <- Successful attempts of this action
# all   omnipresent failure-necessary   dealbreaker
# some  necessary   independent         failure-sufficient
# none  nec+suf     sufficient          unseen
# ^Unsuccessful attempts of this action

# Some examples for trajectories generated by engine3.py on the soko3 domain:
# For all actions, cells being connected the right way is onmipresent (engine3.py doesn't attempt actions on disconnected cells)
# For push-to-goal, the third cell being a goal is necessary (third cell has to be a goal, but if it's occupied by a stone, the action will fail)
# For move, the second cell being clear is necessary and sufficient (moves can only fail if the second cell is occupied, as the engine will ensure the other preconditions are met)
# Can't think of any predicates necessary for any of the moves to fail
# For move, the first cell being a goal is independent (moves onto and off of a goal can fail)
# For all actions, the cells being connected the right way should be necessary (though the engine will never attempt moves where this isn't met)
# Can't think of any predicates that guarantee failure and are the only way the action can fail (which would make them dealbreakers)
# For push-to-goal, the third cell being nongoal is failure-sufficient (guarantees failure, but so does the presence of a rock on the third cell)
# For all moves, a player on the second or third cells is unseen (since the engine always makes the first cell the one with the player)

# I'm not actually sure any of that was useful.

# Anyway, from each action (failed or otherwise), we can compute two things:
# 1. The set of all predicates in the before state attached to the action parameters
# 2. The set of all predicates that could have been in the before state (and would be attached to the action parameters), but weren't.
# If the action succeeded, all predicates in set 1 are allowed to be in the before state. They cannot be negative preconditions.
# Also, all prediates in set 2 do not need to be in the before state. They aren't positive preconditions.
# On the other hand, if the action failed, then either set 1 contains a negative precondition, or set 2 contains a positive precondition.

# My existing code computes all predicates seen before every single successful action (i.e. that could be positive preconditions)
# and all the predicates absent before every single successful action (i.e. that could be negative preconditions).
# I'm now interesred in what predicates definitely are NOT positive/negative preconditions.
# That is, which ones were absent from the before state on at least one successful invocation of the action
# and which ones were present in the before state on at least one successful invocation of the action.
# To get that, I can just take the inverse of the precondition sets generated by my existing code with respect to the set of all concievable predicates matching the type system.

# Lemme name some things.
# U  = "Universe": Set of all concievable predicates that could be relevant to an action, given the types of its parameters. Computed, but not stored, by my earlier code.
# PC = "Positive Candidates": Set of all predicates present before all successful invocations of the action. Could be genuine positive preconditions. Computed and stored by my earlier code.
# NC = "Negative Candidates": Set of all predicates absent before all successful invocations of the action. Could be genuine negative preconditions. Computed and stored by my earlier code.
# B  = "Before": Set of all predicates in U that were actually present in the state before this particular failed invocation of the action.
# A  = U-B = "Absences": Set of all predicates in U not present before this particular failed invocation of the action.
# P  = "Positive" The genuine positive preconditions.
# N  = "Nagative" The genuine negative preconditions. These are out ultimate goal.
# PD = "Positive, Definitely" All predicates that are definitely a positive precondition, based on what information is available.
# ND = "Negative, Definitely" All predicates that are definitely a negative precondition, based on what information is available. We're trying to compute these right now.

# PD <= P <= PC
# ND <= N <= NC

# For every successful action invocation, P <= B and N <= A. Since this invocation failed, though, something in either A or B must break one of those relations.
# Either A lacks a predicate in N, or B lacks a predicate in P.
# Equivalently, B has a predicate in N, or A has a predicate in P.
# More concisely, either B*N is non-empty, or A*P is non-empty,
# Since I don't have P or N, though, I'll have to make do with what I have: PC and NC.
# B*NC = set of all predicates in the before state that could be negative preconditions
# A*PC = set of all predicates absent in the before state that could be positive preconditions
# A*PC should also equal PC - B, which allows me to avoid computing A or U.
#   That's a set-theory identity, right?
#   How's set subtraction defined?
#   S - T = the things that are in S, but not in T
#   S - T = the intersection of S and the complement of T
#   S - T = S * !T
#   So since A = !B, then PC * A = PC - B
# So, yes, the following comment block is accurate.

# So I'll start by running my existing code on all the successul actions.
# Then, for each failed action, I can
#   [B] Compute set of before-state predicates compatible with action parameters (one of which must be a negative precondition, unless the action actually failed because of a positive precondition)
#   [B*NC] Intersect with the previously-computed negative preconditions of the action (the set of all possible negative preconditions compatible with the successful actions)
#   Store the intersection somewhere.
#   [PC] Take a copy of the prefiously-computed positive preconditions
#   [PC-B = PC*A]Subtract the set from the first indented line (the predicates that were in the before state)
#   Store that difference in a tuple alongside the previously-stored set
# Now, I've got a list of pairs, each containing the predicate that's the reason why a particular action failed mixed in with some superfluous info.

# So, how to sort out the important information from the superfluous?
# I want to err on the side of including too few rules. If I cannot conclude with certainty that a particular predicate caused an action to fail, I should not include it.
# So, for each pair, if one set is empty and the other is a singleton, then the predicate in that singleton is the cause. It is either necessary or failure-sufficient. Write it down.
# Go back through the pairs. Most of them should contain at least one precondition written down in the previous step.
# Those that don't must contain at least two preconditions, none of which we've concluded anything about so far.
# I don't think we can conclude anything about them.
# We could look for a single predicate present in all such pairs, but it's concievable that the actual preconditions will be everything but that one.
# So, print them to the screen, say "Hey, we know some of these predicates are preconditions, but we can't tell which ones", and then forget about them.

# Finally, construct ActionCandidate-like objects using the written-down preconditions and the effects from my current code, and print.



class trajectoryRevised(blackout1.trajectory):
    def reviseActions(self):
        for k, v in self.actions.items():
            self.actions[k] = actionRevised(v)
        assignments = [((n - 1) // 2 - 1, block[1]) for (n, block) in enumerate(self.tokens) if block[0] == ':action-failed']
        for i, agmt in assignments:
            act = self.actions[agmt[0]]
            assignment = agmt[1:]
            before = self.states[i]
            print('Failed Action: [{}] {}'.format(i, agmt))
            # print('State: [{}] {}'.format(i, before))
            B = set()
            for pred in before:
                compatible = True
                for arg in pred[1:]:
                    # arg is the actual, grounded argument attached to the predicate. E.g. pos-02-04.
                    # If that's in assignment (also consisting of actual, grounded arguments)
                    # and all the other arguments of pred are as well
                    if arg not in assignment:
                        compatible = False
                        break
                if compatible:
                    # then I need to translate them into the argument names the actionCandidate objects use
                    translated = [pred[0]]
                    for arg in pred[1:]:
                        translated.append(act.parNames[assignment.index(arg)])
                    # and add the result to B
                    B.add(tuple(translated))
            print('Relevant Before-state Predicates: {}'.format(B))
            BNC = B.intersection(act.negativePreconditions)
            PCB = act.positivePreconditions.difference(B)
            act.counterexamples.append((PCB, BNC))
            print('Possible Absent  Positive Preconditions: {}'.format(PCB))
            print('Possible Present Negative Preconditions: {}'.format(BNC))
            print()
        self.ambiguities = []
        for name, act in self.actions.items():
            for pos, neg in act.counterexamples:
                if len(pos) == 0 and len(neg) == 1:
                    act.defNegPrecons.add(next(iter(neg)))
                elif len(pos) == 1 and len(neg) == 0:
                    act.defPosPrecons.add(next(iter(pos)))
            print('{} definite positive preconditions: {}'.format(name, act.defPosPrecons))
            print('{} definite negative preconditions: {}'.format(name, act.defNegPrecons))
            print()
            for pos, neg in act.counterexamples:
                if len(pos) + len(neg) >= 2:    # For every counterexample pair with at least two entries between its sets
                                                # if none of those entries are definitely preconditions
                    if len(pos.intersection(act.defPosPrecons)) + len(neg.intersection(act.defNegPrecons)) == 0:
                        posCan = pos.difference(act.defPosPrecons)
                        negCan = neg.difference(act.defNegPrecons)
                                                # at least one of those counterexamples must be a precondition, but we don't know which
                        print('Warning: Not enough information to determine if {} failed due to lack of {} or presence of {}!'.format(name, posCan, negCan))
                        ambig = (name, posCan, negCan)
                        if ambig not in self.ambiguities:
                            self.ambiguities.append(ambig)
        print()




    def __init__(self, filename, domain='reconstructed'):
        super().__init__(filename, domain)  # Run all the code from my previous trajectory script
        self.times['wallclock_stage2_start'] = time.time_ns()
        self.times['process_stage2_start'] = time.process_time_ns()
        print('\n=========== Failed Action Analysis ==============\n')
        self.reviseActions()
        self.times['wallclock_stage2_end'] = time.time_ns()
        self.times['process_stage2_end'] = time.process_time_ns()
        sys.stderr.write('\nStage 1 wall-clock time: {:,} nanoseconds\n'.format(self.times['wallclock_stage1_end'] - self.times['wallclock_stage1_start']))
        sys.stderr.write('Stage 1 process time:    {:,} nanoseconds\n'.format(self.times['process_stage1_end'] - self.times['process_stage1_start']))
        sys.stderr.write('Stage 2 wall-clock time: {:,} nanoseconds\n'.format(self.times['wallclock_stage2_end'] - self.times['wallclock_stage2_start']))
        sys.stderr.write('Stage 2 process time:    {:,} nanoseconds\n'.format(self.times['process_stage2_end'] - self.times['process_stage2_start']))

class actionRevised(blackout1.actionCandidate):
    def __init__(self, candidate):
        c = self.__class__
        for att in dir(candidate):
            try:
                setattr(self, att, getattr(candidate, att))
            except AttributeError:
                pass
        self.__class__ = c
        self.positivePreconditions = set(map(tuple, self.positivePreconditions))
        self.negativePreconditions = set(map(tuple, self.negativePreconditions))
        self.counterexamples = []
        self.defPosPrecons = set()
        self.defNegPrecons = set()

    def __str__(self):
            params = ['{} - {}'.format(par, '_'.join(typ)) for par, typ in zip(self.parNames, self.parameterTypes)]
            posiPrecons = ['({})'.format(' '.join(pred)) for pred in self.defPosPrecons]
            negaPrecons = ['(not ({}))'.format(' '.join(pred)) for pred in self.defNegPrecons]
            posEffects = ['({})'.format(' '.join(pred)) for pred in self.positiveEffects]
            negEffects = ['(not ({}))'.format(' '.join(pred)) for pred in self.negativeEffects]
            return '''(:action {}
:parameters ({})
:precondition (and {}
{})
:effect (and {}
{}))
'''.format(self.name, ' '.join(params), ' '.join(posiPrecons), ' '.join(negaPrecons), ' '.join(posEffects), ' '.join(negEffects))






# Main
if __name__ == '__main__':
    import sys
    filename = sys.argv[1]
    if len(sys.argv) > 3:
        traj = trajectoryRevised(filename, sys.argv[3])
    else:
        traj = trajectoryRevised(filename)
    if len(sys.argv) > 2:
        fout = open(sys.argv[2], 'w')
    else:
        fout = sys.stdout
    fout.write(str(traj))


